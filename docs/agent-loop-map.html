<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TunaCode Agent Loop Map (Request Loop + Node Orchestrator)</title>
  <style>
    :root {
      --bg: #e9e9e9;
      --panel: #f6f6f6;
      --ink: #111;
      --muted: #444;
      --hairline: #000;

      --layer-ui: #cfe8ff;
      --layer-core: #d7ffd7;
      --layer-orch: #fff2b8;
      --layer-tools: #ffd7ef;
      --layer-infra: #e1ddff;

      --focus: #1d4ed8;
      --shadow: rgba(0,0,0,0.15);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: var(--sans);
      line-height: 1.35;
    }

    header {
      background: linear-gradient(#fdfdfd, #e7e7e7);
      border-bottom: 2px solid var(--hairline);
      padding: 14px 18px;
      box-shadow: 0 2px 0 rgba(0,0,0,0.05);
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    header .sub {
      margin-top: 4px;
      color: var(--muted);
      font-size: 13px;
    }

    .layout {
      display: grid;
      grid-template-columns: 320px minmax(0, 1fr);
      gap: 14px;
      padding: 14px;
      align-items: start;
    }

    nav {
      position: sticky;
      top: 12px;
      background: var(--panel);
      border: 2px solid var(--hairline);
      box-shadow: 3px 3px 0 var(--shadow);
      padding: 12px;
    }

    nav h2 {
      font-size: 13px;
      margin: 0 0 8px 0;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    nav a {
      display: block;
      padding: 6px 8px;
      text-decoration: none;
      color: var(--ink);
      border: 1px solid transparent;
    }

    nav a:hover {
      border-color: var(--hairline);
      background: #fff;
    }

    nav .small {
      color: var(--muted);
      font-size: 12px;
      margin-top: 10px;
      border-top: 1px solid #bbb;
      padding-top: 10px;
    }

    main {
      min-width: 0;
    }

    section {
      background: var(--panel);
      border: 2px solid var(--hairline);
      box-shadow: 3px 3px 0 var(--shadow);
      padding: 14px;
      margin-bottom: 14px;
    }

    section h2 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    section h3 {
      margin: 14px 0 8px;
      font-size: 14px;
    }

    .pill {
      display: inline-block;
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border: 1px solid var(--hairline);
      background: #fff;
      margin-left: 6px;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .note {
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    code, pre {
      font-family: var(--mono);
      font-size: 12px;
    }

    pre {
      background: #fff;
      border: 1px solid #999;
      padding: 10px;
      overflow: auto;
      margin: 10px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      border: 1px solid #999;
      font-size: 13px;
    }

    th, td {
      border: 1px solid #999;
      padding: 8px;
      vertical-align: top;
    }

    th {
      background: #f0f0f0;
      text-align: left;
    }

    details {
      border: 1px solid #999;
      background: #fff;
      padding: 10px;
      margin: 10px 0;
    }

    summary {
      cursor: pointer;
      font-weight: 700;
    }

    .legend {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
      margin: 8px 0 0;
      font-size: 12px;
    }

    .legend .item {
      border: 1px solid var(--hairline);
      padding: 6px;
      background: #fff;
    }

    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border: 1px solid var(--hairline);
      margin-right: 6px;
      vertical-align: baseline;
    }

    .layer-ui { background: var(--layer-ui); }
    .layer-core { background: var(--layer-core); }
    .layer-orch { background: var(--layer-orch); }
    .layer-tools { background: var(--layer-tools); }
    .layer-infra { background: var(--layer-infra); }

    .svgwrap {
      overflow: auto;
      border: 1px solid #999;
      background: #fff;
    }

    svg {
      width: 100%;
      height: auto;
      min-width: 980px;
    }

    .box {
      stroke: #000;
      stroke-width: 1.5;
      rx: 6;
      ry: 6;
    }

    .label {
      font-family: var(--sans);
      font-size: 12px;
      fill: #111;
    }

    .label.small {
      font-size: 11px;
      fill: #333;
    }

    .arrow {
      stroke: #000;
      stroke-width: 1.4;
      fill: none;
      marker-end: url(#arrow);
    }

    .jump {
      font-family: var(--mono);
      font-size: 11px;
      fill: #1d4ed8;
      text-decoration: underline;
    }

    .hilite {
      outline: 3px solid var(--focus);
      outline-offset: 3px;
    }

    .k {
      display: inline-block;
      font-family: var(--mono);
      font-size: 12px;
      padding: 1px 6px;
      border: 1px solid #000;
      background: #fff;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>TunaCode Agent Loop Map</h1>
    <div class="sub">
      Request loop + per-node orchestrator, mapped to code files and contracts.
      This is a <span class="k">code-derived</span> report (see: <span class="k">docs/agent-loop-ontology.md</span>).
    </div>
  </header>

  <div class="layout">
    <nav>
      <h2>Sections</h2>
      <a href="#layer-map">Layer map (UI → Core → Orchestrator → Tools)</a>
      <a href="#sequence">Sequence map (per request → per node)</a>
      <a href="#io">Inputs / outputs (public contracts)</a>
      <a href="#state">State mutations & invariants</a>
      <a href="#structural">Structural typing contracts (Nodes, Parts)</a>
      <a href="#failure">Failure / intervention paths</a>
      <a href="#symbols">Code pointers (files + symbols)</a>

      <div class="small">
        <div><strong>How to use:</strong></div>
        <div>Click any box label in diagrams to jump to its code pointer.</div>
        <div class="note">All paths are relative to repository root.</div>
      </div>
    </nav>

    <main>
      <section id="layer-map">
        <h2>Layer map <span class="pill">architecture overview</span></h2>
        <div class="note">
          This diagram shows the dominant data/control flow direction for a single request.
          Boxes are grouped by layer; arrows show which layer calls which.
        </div>

        <div class="legend" aria-label="Layer legend">
          <div class="item"><span class="swatch layer-ui"></span>UI (Textual) layer</div>
          <div class="item"><span class="swatch layer-core"></span>Core request loop</div>
          <div class="item"><span class="swatch layer-orch"></span>Node orchestrator + tool dispatch</div>
          <div class="item"><span class="swatch layer-tools"></span>Tooling (tool functions, parsing)</div>
          <div class="item"><span class="swatch layer-infra"></span>Infrastructure (framework types, cache)</div>
        </div>

        <div class="svgwrap">
          <svg viewBox="0 0 1200 540" role="img" aria-label="Layer map">
            <defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L10,3 L0,6 Z" fill="#000" />
              </marker>
            </defs>

            <!-- UI layer -->
            <rect class="box" x="40" y="40" width="320" height="90" fill="var(--layer-ui)" />
            <text class="label" x="56" y="66">UI: Textual app</text>
            <a href="#sym-ui-app"><text class="jump" x="56" y="88">src/tunacode/ui/app.py</text></a>
            <text class="label small" x="56" y="108">calls process_request(...)</text>

            <!-- Core request loop -->
            <rect class="box" x="440" y="40" width="360" height="110" fill="var(--layer-core)" />
            <text class="label" x="456" y="66">Core: Request loop</text>
            <a href="#sym-core-main"><text class="jump" x="456" y="88">src/tunacode/core/agents/main.py</text></a>
            <text class="label small" x="456" y="108">RequestOrchestrator + process_request</text>
            <text class="label small" x="456" y="128">agent.iter(...) → nodes</text>

            <!-- Node orchestrator layer -->
            <rect class="box" x="860" y="40" width="300" height="160" fill="var(--layer-orch)" />
            <text class="label" x="876" y="66">Node orchestrator</text>
            <a href="#sym-orch-process-node"><text class="jump" x="876" y="88">.../orchestrator/orchestrator.py</text></a>
            <text class="label small" x="876" y="108">process_node(node, ...)</text>
            <text class="label small" x="876" y="128">usage + thought + tool returns</text>
            <text class="label small" x="876" y="148">dispatch_tools(...)</text>

            <!-- Tools layer -->
            <rect class="box" x="860" y="250" width="300" height="120" fill="var(--layer-tools)" />
            <text class="label" x="876" y="276">Tools + parsing</text>
            <a href="#sym-tool-dispatch"><text class="jump" x="876" y="298">src/tunacode/tools/*</text></a>
            <text class="label small" x="876" y="318">tool_parser / command_parser</text>
            <text class="label small" x="876" y="338">tool functions (bash/read_file/...)</text>

            <!-- Infra layer -->
            <rect class="box" x="440" y="210" width="360" height="160" fill="var(--layer-infra)" />
            <text class="label" x="456" y="236">Infrastructure</text>
            <a href="#sym-infra-llm"><text class="jump" x="456" y="258">src/tunacode/infrastructure/llm_types.py</text></a>
            <text class="label small" x="456" y="278">framework type re-exports (AgentRun=Any)</text>
            <a href="#sym-infra-agent-cache"><text class="jump" x="456" y="302">.../cache/caches/agents.py</text></a>
            <text class="label small" x="456" y="322">agent cache (module-level)</text>
            <a href="#sym-core-agent-config"><text class="jump" x="456" y="346">.../agent_components/agent_config.py</text></a>
            <text class="label small" x="456" y="366">get_or_create_agent(...)</text>

            <!-- Arrows -->
            <path class="arrow" d="M360,85 L440,85" />
            <path class="arrow" d="M800,95 L860,95" />
            <path class="arrow" d="M800,130 L860,130" />
            <path class="arrow" d="M1010,200 L1010,250" />
            <path class="arrow" d="M620,150 L620,210" />
            <path class="arrow" d="M860,120 L800,120" />
            <text class="label small" x="372" y="78">message + callbacks</text>
            <text class="label small" x="806" y="88">node</text>
            <text class="label small" x="826" y="152">tool parts</text>
            <text class="label small" x="630" y="198">agent + caches</text>
          </svg>
        </div>
      </section>

      <section id="sequence">
        <h2>Sequence map <span class="pill">what runs, in order</span></h2>
        <div class="note">
          This sequence is <strong>exactly</strong> what the current implementation does.
          It distinguishes the outer request loop (one user message) from the inner per-node loop.
        </div>

        <div class="svgwrap">
          <svg viewBox="0 0 1200 520" role="img" aria-label="Sequence map">
            <defs>
              <marker id="arrow2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L10,3 L0,6 Z" fill="#000" />
              </marker>
            </defs>

            <!-- Lane headings -->
            <text class="label" x="60" y="40">UI</text>
            <text class="label" x="320" y="40">Request loop</text>
            <text class="label" x="650" y="40">Node orchestrator</text>
            <text class="label" x="960" y="40">Tools / Registry</text>

            <!-- Lifelines -->
            <path d="M80,55 L80,490" stroke="#000" stroke-dasharray="4 4" />
            <path d="M360,55 L360,490" stroke="#000" stroke-dasharray="4 4" />
            <path d="M700,55 L700,490" stroke="#000" stroke-dasharray="4 4" />
            <path d="M1020,55 L1020,490" stroke="#000" stroke-dasharray="4 4" />

            <!-- Steps -->
            <rect class="box" x="40" y="70" width="80" height="40" fill="var(--layer-ui)" />
            <text class="label" x="52" y="95">submit</text>

            <rect class="box" x="250" y="70" width="220" height="55" fill="var(--layer-core)" />
            <text class="label" x="262" y="95">process_request(...)</text>
            <a href="#sym-core-main"><text class="jump" x="262" y="115">core/agents/main.py</text></a>

            <path d="M120,90 L250,90" stroke="#000" stroke-width="1.4" fill="none" marker-end="url(#arrow2)" />

            <rect class="box" x="240" y="150" width="240" height="70" fill="var(--layer-core)" />
            <text class="label" x="252" y="175">RequestOrchestrator.run()</text>
            <text class="label small" x="252" y="195">timeout wrapper</text>
            <text class="label small" x="252" y="213">_run_impl()</text>

            <path d="M360,125 L360,150" stroke="#000" stroke-width="1.4" marker-end="url(#arrow2)" />

            <rect class="box" x="240" y="240" width="240" height="92" fill="var(--layer-core)" />
            <text class="label" x="252" y="266">Initialize request</text>
            <text class="label small" x="252" y="286">reset runtime + registry</text>
            <text class="label small" x="252" y="306">get_or_create_agent()</text>
            <text class="label small" x="252" y="326">prepare history</text>

            <path d="M360,220 L360,240" stroke="#000" stroke-width="1.4" marker-end="url(#arrow2)" />

            <rect class="box" x="240" y="350" width="240" height="70" fill="var(--layer-core)" />
            <text class="label" x="252" y="375">agent.iter(...)</text>
            <text class="label small" x="252" y="395">async for node in run_handle</text>

            <path d="M480,385 L610,385" stroke="#000" stroke-width="1.4" fill="none" marker-end="url(#arrow2)" />

            <rect class="box" x="610" y="350" width="180" height="110" fill="var(--layer-orch)" />
            <text class="label" x="622" y="375">process_node(node)</text>
            <text class="label small" x="622" y="395">emit_tool_returns</text>
            <text class="label small" x="622" y="415">record_thought</text>
            <text class="label small" x="622" y="435">update_usage</text>
            <text class="label small" x="622" y="455">dispatch_tools</text>

            <path d="M790,430 L940,430" stroke="#000" stroke-width="1.4" fill="none" marker-end="url(#arrow2)" />

            <rect class="box" x="940" y="390" width="160" height="85" fill="var(--layer-tools)" />
            <text class="label" x="952" y="415">tool_dispatcher</text>
            <text class="label small" x="952" y="435">register/start/fail</text>
            <text class="label small" x="952" y="455">execute_tools_parallel</text>

            <path d="M700,460 L700,490" stroke="#000" stroke-width="1.4" marker-end="url(#arrow2)" />
            <path d="M360,420 L360,490" stroke="#000" stroke-width="1.4" marker-end="url(#arrow2)" />

            <rect class="box" x="240" y="455" width="240" height="45" fill="#fff" />
            <text class="label" x="252" y="483">persist run messages</text>

            <text class="label small" x="500" y="494">(loop ends when run_handle ends, or when response_state.task_completed is True)</text>
          </svg>
        </div>
      </section>

      <section id="io">
        <h2>Inputs / outputs <span class="pill">public contracts</span></h2>

        <h3>Primary entry point</h3>
        <pre><code>async def process_request(
    message: str,
    model: ModelName,
    state_manager: StateManagerProtocol,
    tool_callback: ToolCallback | None = None,
    streaming_callback: StreamingCallback | None = None,
    tool_result_callback: ToolResultCallback | None = None,
    tool_start_callback: ToolStartCallback | None = None,
    notice_callback: NoticeCallback | None = None,
) -&gt; AgentRun</code></pre>

        <table>
          <thead><tr><th>Parameter</th><th>Type</th><th>Semantics</th></tr></thead>
          <tbody>
            <tr><td><code>message</code></td><td><code>str</code></td><td>User prompt for the request. Copied into <code>session.task.original_query</code> after reset.</td></tr>
            <tr><td><code>model</code></td><td><code>ModelName = str</code></td><td>Model selector passed into <code>get_or_create_agent(...)</code>.</td></tr>
            <tr><td><code>state_manager</code></td><td><code>StateManagerProtocol</code></td><td>Provides <code>.session</code> with runtime/task/conversation/usage + caches.</td></tr>
            <tr><td><code>tool_callback</code></td><td><code>ToolCallback | None</code></td><td>Executor hook called once per tool call when dispatching tools.</td></tr>
            <tr><td><code>streaming_callback</code></td><td><code>StreamingCallback | None</code></td><td>If set and the node supports streaming, receives ordered text deltas.</td></tr>
            <tr><td><code>tool_result_callback</code></td><td><code>ToolResultCallback | None</code></td><td>Called when tool-return parts are observed in the next request.</td></tr>
            <tr><td><code>tool_start_callback</code></td><td><code>ToolStartCallback | None</code></td><td>Called once per tool batch with a display label.</td></tr>
            <tr><td><code>notice_callback</code></td><td><code>NoticeCallback | None</code></td><td>Used when an “empty response” is detected to show an intervention notice.</td></tr>
          </tbody>
        </table>

        <h3>Return value</h3>
        <table>
          <thead><tr><th>Return</th><th>Type</th><th>Contract</th></tr></thead>
          <tbody>
            <tr>
              <td><code>AgentRun</code></td>
              <td><code>Any</code> (framework run handle) wrapped</td>
              <td>
                The returned object delegates to the underlying run handle and adds
                <code>.response_state</code>.
                The loop persists <code>run_handle.all_messages()</code> into <code>session.conversation.messages</code> at end.
              </td>
            </tr>
          </tbody>
        </table>

        <div class="note">
          Implementation detail that matters for replaceability: the loop relies on
          <code>run_handle.ctx</code> for streaming, and on <code>run_handle.all_messages()</code>
          for persistence.
        </div>
      </section>

      <section id="state">
        <h2>State mutations & invariants <span class="pill">replacement-critical</span></h2>

        <div class="grid2">
          <div>
            <h3>Per-request resets (authoritative)</h3>
            <table>
              <thead><tr><th>Field</th><th>New value</th></tr></thead>
              <tbody>
                <tr><td><code>session.runtime.current_iteration</code></td><td><code>0</code></td></tr>
                <tr><td><code>session.runtime.iteration_count</code></td><td><code>0</code></td></tr>
                <tr><td><code>session.runtime.request_id</code></td><td>new UUID4 prefix (8 chars)</td></tr>
                <tr><td><code>session.runtime.tool_registry</code></td><td><code>clear()</code></td></tr>
                <tr><td><code>session.runtime.batch_counter</code></td><td><code>0</code></td></tr>
                <tr><td><code>session.runtime.consecutive_empty_responses</code></td><td><code>0</code></td></tr>
                <tr><td><code>session.task.original_query</code></td><td>cleared then set to <code>message</code></td></tr>
              </tbody>
            </table>
          </div>
          <div>
            <h3>Tool registry lifecycle invariant</h3>
            <table>
              <thead><tr><th>Event</th><th>Registry effect</th><th>Why it matters</th></tr></thead>
              <tbody>
                <tr><td>Tool call discovered</td><td><code>register(tool_call_id, tool_name, args)</code></td><td>Tool returns later resolve args by tool_call_id.</td></tr>
                <tr><td>Tool execution begins</td><td><code>start(tool_call_id)</code></td><td>UI/tool panels rely on accurate lifecycle.</td></tr>
                <tr><td>Tool return observed</td><td><code>complete(tool_call_id, result)</code></td><td>Tool result callback is called with resolved args + result.</td></tr>
                <tr><td>Execution fails</td><td><code>fail(...)</code> or <code>cancel(...)</code></td><td>Failure is recorded even if model never sees tool return.</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <h3>Persistence rule (messages)</h3>
        <details>
          <summary>Conversation messages are replaced by authoritative run messages at end (plus preserved external appends)</summary>
          <pre><code>run_messages = list(run_handle.all_messages())
external_messages = conversation.messages[baseline_message_count:]
conversation.messages = [*run_messages, *external_messages]</code></pre>
        </details>

        <h3>Known gaps (as implemented)</h3>
        <table>
          <thead><tr><th>Gap</th><th>Where</th><th>Effect</th></tr></thead>
          <tbody>
            <tr>
              <td><code>max_iterations</code> computed but not enforced</td>
              <td><code>core/agents/main.py</code></td>
              <td>Loop ends when framework run handle ends (or if <code>response_state.task_completed</code> is set elsewhere).</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="structural">
        <h2>Structural typing contracts <span class="pill">framework-agnostic surface</span></h2>
        <div class="note">
          Many framework objects are typed as <code>Any</code>. The real contract is the set of attributes TunaCode reads.
          If you replace the framework, your adapter must provide these.
        </div>

        <h3>Node contract (attributes read)</h3>
        <table>
          <thead><tr><th>Attribute</th><th>Used by</th><th>Notes</th></tr></thead>
          <tbody>
            <tr><td><code>node.request</code></td><td><code>process_node</code></td><td>If present, <code>request.parts</code> is scanned for <code>part_kind == "tool-return"</code>.</td></tr>
            <tr><td><code>node.model_response</code></td><td><code>process_node</code></td><td>If missing, node is treated as non-response and finalizes state.</td></tr>
            <tr><td><code>node.thought</code></td><td><code>process_node</code></td><td>Appended to <code>session.conversation.thoughts</code>.</td></tr>
            <tr><td><code>node.result.output</code></td><td><code>main._handle_iteration_node</code></td><td>Used to mark that a user-visible response exists.</td></tr>
            <tr><td><code>node.stream(ctx)</code></td><td><code>stream_model_request_node</code></td><td>Optional. Must be an async CM yielding an async iterator of delta events.</td></tr>
          </tbody>
        </table>

        <h3>Part contract (attributes read)</h3>
        <table>
          <thead><tr><th>Attribute</th><th>Meaning</th><th>Used for</th></tr></thead>
          <tbody>
            <tr><td><code>part.part_kind</code></td><td>discriminator string</td><td>text/tool-call/tool-return routing</td></tr>
            <tr><td><code>part.content</code></td><td>text or tool output</td><td>content extraction + tool return stringification</td></tr>
            <tr><td><code>part.tool_call_id</code></td><td>tool call identity</td><td>registry lookup + lifecycle updates</td></tr>
            <tr><td><code>part.tool_name</code></td><td>tool name</td><td>display + registry bookkeeping</td></tr>
            <tr><td><code>part.args</code></td><td>raw tool args</td><td>normalized via <code>parse_args</code></td></tr>
          </tbody>
        </table>
      </section>

      <section id="failure">
        <h2>Failure / intervention paths <span class="pill">exceptions + cleanup</span></h2>
        <div class="note">
          These behaviors are part of the replacement contract because they mutate session state,
          invalidate caches, and/or rewrite conversation history.
        </div>

        <h3>Global request timeout</h3>
        <details open>
          <summary><code>RequestOrchestrator.run()</code> wraps the request in <code>asyncio.wait_for</code> (if enabled)</summary>
          <ul>
            <li>Timeout configured by <code>settings.global_request_timeout</code> (0 disables timeout).</li>
            <li>On timeout:
              <ul>
                <li><code>invalidate_agent_cache(model, state_manager)</code></li>
                <li>raise <code>GlobalRequestTimeoutError(timeout)</code></li>
              </ul>
            </li>
          </ul>
        </details>

        <h3>User abort / cancellation</h3>
        <details>
          <summary>On <code>UserAbortError</code> or <code>asyncio.CancelledError</code>, abort cleanup runs</summary>
          <ol>
            <li>If partial streamed text exists in <code>session._debug_raw_stream_accum</code>, append an interrupted synthetic response message.</li>
            <li>Sanitize conversation history:
              <ul>
                <li>remove dangling tool calls</li>
                <li>remove empty responses</li>
                <li>remove consecutive requests</li>
              </ul>
            </li>
            <li>Invalidate agent cache for the model.</li>
          </ol>
        </details>

        <h3>Empty response intervention ("model said nothing")</h3>
        <details>
          <summary>Triggered when a node has no non-empty text and no structured tool calls</summary>
          <ul>
            <li><code>process_node(...)</code> returns <code>(is_empty=True, reason="empty")</code>.</li>
            <li><code>EmptyResponseHandler</code> increments <code>runtime.consecutive_empty_responses</code>.</li>
            <li>Intervention currently triggers at <code>&gt;= 1</code> consecutive empty response:
              <ul>
                <li>builds a corrective notice via <code>handle_empty_response(...)</code></li>
                <li>emits it via <code>notice_callback(notice)</code> (if provided)</li>
                <li>resets consecutive count to 0</li>
              </ul>
            </li>
          </ul>
        </details>

        <h3>Tool execution failures + retries</h3>
        <details>
          <summary><code>execute_tools_parallel(...)</code> retries failures (except non-retryable classes)</summary>
          <ul>
            <li>Retry policy is in <code>src/tunacode/core/agents/agent_components/tool_executor.py</code>.</li>
            <li>Non-retryable errors include <code>UserAbortError</code>, <code>ModelRetry</code>, validation/config/file errors.</li>
            <li>Ultimate failure is recorded via the tool registry failure callback:
              <ul>
                <li><code>tool_registry.fail(tool_call_id, detail)</code> or</li>
                <li><code>tool_registry.cancel(tool_call_id, reason)</code></li>
              </ul>
            </li>
          </ul>
        </details>
      </section>

      <section id="symbols">
        <h2>Code pointers <span class="pill">files + symbols</span></h2>

        <details id="sym-ui-app" open>
          <summary>UI entry: Textual request submission</summary>
          <p><code>src/tunacode/ui/app.py</code></p>
          <ul>
            <li>Calls <code>process_request(...)</code> inside <code>TextualReplApp._process_request</code></li>
            <li>Wires callbacks: <code>tool_callback</code>, <code>tool_result_callback</code>, <code>tool_start_callback</code>, <code>notice_callback</code></li>
          </ul>
        </details>

        <details id="sym-core-main" open>
          <summary>Core request loop: RequestOrchestrator + process_request</summary>
          <p><code>src/tunacode/core/agents/main.py</code></p>
          <ul>
            <li><code>class RequestOrchestrator</code>: owns timeout + run + iteration loop</li>
            <li><code>async def process_request(...)</code>: public entry point</li>
            <li>Persists messages via <code>run_handle.all_messages()</code></li>
          </ul>
        </details>

        <details id="sym-core-agent-config">
          <summary>Agent creation + caching: get_or_create_agent / invalidate_agent_cache</summary>
          <p><code>src/tunacode/core/agents/agent_components/agent_config.py</code></p>
          <ul>
            <li><code>get_or_create_agent(model, state_manager)</code>: builds system prompt + tool list + HTTP client, then caches</li>
            <li><code>invalidate_agent_cache(model, state_manager)</code>: called on abort/timeout</li>
          </ul>
        </details>

        <details id="sym-orch-process-node" open>
          <summary>Node orchestrator: process_node(...)</summary>
          <p><code>src/tunacode/core/agents/agent_components/orchestrator/orchestrator.py</code></p>
          <ul>
            <li>Transitions response state (ASSISTANT → TOOL_EXECUTION → RESPONSE)</li>
            <li>Consumes tool returns from <code>node.request.parts</code></li>
            <li>Dispatches tool calls from <code>node.model_response.parts</code></li>
            <li>Determines “empty response” (no text + no structured tool calls)</li>
          </ul>
        </details>

        <details id="sym-tool-dispatch">
          <summary>Tool dispatch: structured + fallback tool call collection</summary>
          <p><code>src/tunacode/core/agents/agent_components/orchestrator/tool_dispatcher.py</code></p>
          <ul>
            <li><code>dispatch_tools(parts, node, state_manager, tool_callback, ...)</code></li>
            <li>Collection: <code>.../_tool_dispatcher_collection.py</code></li>
            <li>Registry ops + arg normalization: <code>.../_tool_dispatcher_registry.py</code></li>
            <li>Parallel execution + retries: <code>.../_tool_dispatcher_execution.py</code> + <code>.../tool_executor.py</code></li>
          </ul>
        </details>

        <details id="sym-infra-llm">
          <summary>Framework type shim: llm_types</summary>
          <p><code>src/tunacode/infrastructure/llm_types.py</code></p>
          <ul>
            <li>Re-exports pydantic-ai types behind a stable module boundary</li>
            <li><code>AgentRun = Any</code> (structural typing in practice)</li>
          </ul>
        </details>

        <details id="sym-infra-agent-cache">
          <summary>Module-level agent cache</summary>
          <p><code>src/tunacode/infrastructure/cache/caches/agents.py</code></p>
          <ul>
            <li>Manual cache keyed by model name + version metadata</li>
          </ul>
        </details>

        <details>
          <summary>State protocols and structures</summary>
          <ul>
            <li><code>src/tunacode/core/types/state.py</code> — <code>StateManagerProtocol</code>, <code>SessionStateProtocol</code></li>
            <li><code>src/tunacode/core/types/state_structures.py</code> — runtime/task/conversation/usage dataclasses</li>
            <li><code>src/tunacode/core/types/tool_registry.py</code> — <code>ToolCallRegistry</code></li>
          </ul>
        </details>
      </section>

      <section>
        <h2>Deliverables</h2>
        <ol>
          <li><strong>Single source of truth doc:</strong> <code>docs/agent-loop-ontology.md</code></li>
          <li><strong>HTML map/report:</strong> <code>docs/agent-loop-map.html</code> (this file)</li>
        </ol>
      </section>

    </main>
  </div>

  <script>
    // Small UX: highlight the element targeted by the hash.
    function highlightHashTarget() {
      document.querySelectorAll('.hilite').forEach(el => el.classList.remove('hilite'));
      if (!location.hash) return;
      const target = document.querySelector(location.hash);
      if (!target) return;
      target.classList.add('hilite');
      // If it's a <details>, open it so the content is visible.
      if (target.tagName && target.tagName.toLowerCase() === 'details') {
        target.open = true;
      }
    }
    window.addEventListener('hashchange', highlightHashTarget);
    highlightHashTarget();
  </script>
</body>
</html>
