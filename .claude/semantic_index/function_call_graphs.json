{
  "metadata": {
    "version": "1.0.0",
    "generated_date": "2025-09-19",
    "description": "Function call graphs for TunaCode agent system - documents the semantic relationships and data flow after the major refactor that removed triple redundancy"
  },
  "call_graphs": {
    "main_agent_system": {
      "entry_point": "tunacode.core.agents.main.process_request",
      "description": "Primary agent orchestration and request processing - achieves single source of truth",
      "calls": [
        {
          "from": "process_request",
          "to": "agent_components.get_or_create_agent",
          "type": "delegation",
          "purpose": "Acquire configured agent instance with caching"
        },
        {
          "from": "process_request",
          "to": "agent_components._process_node",
          "type": "iteration",
          "purpose": "Core node processing delegated to components"
        },
        {
          "from": "process_request",
          "to": "_init_context",
          "type": "setup",
          "purpose": "Initialize request context with configuration"
        },
        {
          "from": "process_request",
          "to": "_finalize_buffered_tasks",
          "type": "cleanup",
          "purpose": "Execute remaining buffered read-only tools"
        },
        {
          "from": "process_request",
          "to": "_build_fallback_output",
          "type": "fallback",
          "purpose": "Generate synthesized response when task incomplete"
        },
        {
          "from": "process_request",
          "to": "_force_action_if_unproductive",
          "type": "recovery",
          "purpose": "Force agent action when stuck in unproductive loops"
        },
        {
          "from": "process_request",
          "to": "_maybe_force_react_snapshot",
          "type": "instrumentation",
          "purpose": "Force react scratchpad updates every two iterations (max five)"
        }
      ]
    },
    "agent_components_system": {
      "description": "Modular component system for agent functionality - single source of truth achieved",
      "components": [
        {
          "name": "agent_config",
          "entry": "get_or_create_agent",
          "purpose": "Agent creation and configuration with system prompt caching",
          "dependencies": [
            "system prompt loading",
            "MCP server integration",
            "tool registration"
          ]
        },
        {
          "name": "node_processor",
          "entry": "_process_node",
          "purpose": "Core processing logic for agent responses",
          "dependencies": [
            "tool execution",
            "completion detection",
            "state management"
          ]
        },
        {
          "name": "response_state",
          "entry": "ResponseState",
          "purpose": "State management using enum-based state machine",
          "dependencies": [
            "state_transition",
            "AgentState enum"
          ]
        },
        {
          "name": "task_completion",
          "entry": "check_task_completion",
          "purpose": "Detect task completion markers in responses",
          "dependencies": [
            "regex patterns",
            "content cleaning"
          ]
        },
        {
          "name": "tool_buffer",
          "entry": "ToolBuffer",
          "purpose": "Buffer read-only tools for parallel execution",
          "dependencies": [
            "tool_executor",
            "READ_ONLY_TOOLS constant"
          ]
        },
        {
          "name": "streaming",
          "entry": "stream_model_request_node",
          "purpose": "Token streaming for real-time responses",
          "dependencies": [
            "pydantic_ai streaming APIs"
          ]
        }
      ]
    },
    "tool_execution_flow": {
      "description": "Parallel tool execution with batching optimization",
      "flow": [
        {
          "step": 1,
          "component": "tool_buffer",
          "function": "add",
          "purpose": "Buffer read-only tools when encountered"
        },
        {
          "step": 2,
          "component": "tool_executor",
          "function": "execute_tools_parallel",
          "purpose": "Execute buffered tools in parallel batches"
        },
        {
          "step": 3,
          "component": "tool_executor",
          "function": "create_buffering_callback",
          "purpose": "Create callback that handles buffering logic"
        }
      ]
    },
    "state_machine_flow": {
      "description": "Enhanced state machine for agent processing",
      "states": {
        "USER_INPUT": {
          "transitions_to": [
            "ASSISTANT"
          ],
          "purpose": "Initial state - user prompt received"
        },
        "ASSISTANT": {
          "transitions_to": [
            "TOOL_EXECUTION",
            "RESPONSE"
          ],
          "purpose": "Reasoning/deciding phase"
        },
        "TOOL_EXECUTION": {
          "transitions_to": [
            "RESPONSE"
          ],
          "purpose": "Tool execution phase"
        },
        "RESPONSE": {
          "transitions_to": [
            "ASSISTANT"
          ],
          "purpose": "Handling results, may complete or loop"
        }
      },
      "completion_detection": {
        "marker": "TUNACODE DONE:",
        "state": "RESPONSE",
        "function": "check_task_completion"
      }
    },
    "configuration_flow": {
      "description": "Agent configuration and setup",
      "components": [
        {
          "name": "system_prompt",
          "function": "load_system_prompt",
          "caching": "Module-level _PROMPT_CACHE and _TUNACODE_CACHE",
          "purpose": "Load and cache system prompts with file watching"
        },
        {
          "name": "agent_creation",
          "function": "get_or_create_agent",
          "caching": "Module-level _AGENT_CACHE",
          "purpose": "Create and cache agent instances per model"
        },
        {
          "name": "mcp_integration",
          "function": "get_mcp_servers",
          "purpose": "Integrate Model Context Protocol servers"
        },
        {
          "name": "react_snapshot",
          "function": "_maybe_force_react_snapshot",
          "purpose": "Auto invoke ReactTool every two iterations (max five)"
        }
      ]
    },
    "recovery_mechanisms": {
      "description": "Robust error handling and recovery systems",
      "mechanisms": [
        {
          "name": "empty_response_recovery",
          "function": "_handle_empty_response",
          "trigger": "Empty model responses",
          "action": "Inject retry guidance prompt"
        },
        {
          "name": "unproductivity_recovery",
          "function": "_force_action_if_unproductive",
          "trigger": "3+ iterations without tool usage",
          "action": "Force action or completion"
        },
        {
          "name": "fallback_synthesis",
          "function": "_build_fallback_output",
          "trigger": "Iteration limit reached without completion",
          "action": "Generate comprehensive summary of progress"
        },
        {
          "name": "json_parsing_fallback",
          "function": "parse_json_tool_calls",
          "trigger": "Structured tool calling failures",
          "action": "Parse and execute JSON-formatted tool calls"
        }
      ]
    },
    "react_tool_flow": {
      "description": "Reactive scratchpad auto logging",
      "flow": [
        {
          "step": 1,
          "component": "_maybe_force_react_snapshot",
          "function": "auto snapshot",
          "purpose": "Invoke ReactTool with think action every two iterations up to five times"
        },
        {
          "step": 2,
          "component": "ReactTool",
          "function": "execute",
          "purpose": "Record think entry on react_scratchpad"
        },
        {
          "step": 3,
          "component": "StateManager",
          "function": "react_forced_calls",
          "purpose": "Track number of forced snapshots to enforce limit"
        },
        {
          "step": 4,
          "component": "create_user_message",
          "function": "inject guidance",
          "purpose": "Inject guidance as system prompt to influence next LLM turn"
        }
      ]
    }
    ,
    "resume_command_flow": {
      "description": "Enhanced session persistence via /resume command with auto-description",
      "entry_points": [
        "cli.commands.implementations.resume.ResumeCommand.execute"
      ],
      "calls": [
        {
          "from": "ResumeCommand._handle_save",
          "to": "utils.session_utils.save_session_state",
          "type": "io",
          "purpose": "Persist essential SessionState to JSON with enhanced serialization"
        },
        {
          "from": "utils.session_utils.save_session_state",
          "to": "utils.session_utils._collect_essential_state",
          "type": "data",
          "purpose": "Extract and serialize essential session fields"
        },
        {
          "from": "utils.session_utils._collect_essential_state",
          "to": "utils.session_utils._serialize_message",
          "type": "data",
          "purpose": "Enhanced message serialization preserving tool calls and structure"
        },
        {
          "from": "utils.session_utils._serialize_message",
          "to": "utils.session_utils._serialize_message_part",
          "type": "data",
          "purpose": "Serialize individual message parts with sensitive data filtering"
        },
        {
          "from": "utils.session_utils.save_session_state",
          "to": "utils.session_id_generator.generate_user_friendly_session_id",
          "type": "naming",
          "purpose": "Generate session ID with auto-description from current messages"
        },
        {
          "from": "utils.session_id_generator.generate_user_friendly_session_id",
          "to": "utils.session_id_generator._generate_session_description",
          "type": "naming",
          "purpose": "Extract meaningful keywords from user messages for session naming"
        },
        {
          "from": "ResumeCommand._handle_load",
          "to": "utils.session_utils.load_session_state",
          "type": "io",
          "purpose": "Restore essential SessionState from JSON"
        },
        {
          "from": "ResumeCommand._handle_list",
          "to": "utils.session_utils.list_saved_sessions",
          "type": "io",
          "purpose": "Enumerate saved session files with metadata"
        },
        {
          "from": "utils.session_utils.save_session_state",
          "to": "utils.system.get_session_dir",
          "type": "path",
          "purpose": "Resolve ~/.tunacode/sessions/{session_id}"
        },
        {
          "from": "utils.session_utils.load_session_state",
          "to": "utils.system.get_tunacode_home",
          "type": "path",
          "purpose": "Locate sessions directory under ~/.tunacode"
        },
        {
          "from": "utils.session_utils.list_saved_sessions",
          "to": "utils.system.get_tunacode_home",
          "type": "path",
          "purpose": "Locate sessions directory under ~/.tunacode"
        }
      ]
    }
    ,
    "repl_autosave_flow": {
      "description": "Initial session auto-save on REPL startup",
      "entry_points": [
        "cli.repl.repl"
      ],
      "calls": [
        {
          "from": "repl (startup path)",
          "to": "utils.session_utils.save_session_state",
          "type": "io",
          "purpose": "Persist baseline snapshot for new session"
        }
      ]
    }
    ,
    "per_message_autosave": {
      "description": "Autosave after each processed message",
      "entry_points": [
        "cli.repl.execute_repl_request"
      ],
      "calls": [
        {
          "from": "execute_repl_request (post-output)",
          "to": "utils.session_utils.save_session_state",
          "type": "io",
          "purpose": "Continuously persist session state after each turn"
        }
      ]
    }
    ,
    "canonical_session_ids": {
      "description": "Canonical session ID generation and validation flow",
      "entry_points": [
        "utils.session_id_generator.generate_user_friendly_session_id",
        "utils.session_utils._is_safe_session_id"
      ],
      "calls": [
        {
          "from": "generate_user_friendly_session_id",
          "to": "_generate_session_description",
          "type": "data",
          "purpose": "Derive session slug from recent user messages"
        },
        {
          "from": "generate_user_friendly_session_id",
          "to": "uuid.uuid4",
          "type": "utility",
          "purpose": "Produce 6-char lowercase hex shortid"
        },
        {
          "from": "_is_safe_session_id",
          "to": "re.fullmatch",
          "type": "validation",
          "purpose": "Accept canonical IDs and legacy UUIDs"
        }
      ]
    }
  },
  "refactor_summary": {
    "date": "2025-09-19",
    "major_changes": [
      "Removed triple redundancy in agent functions",
      "Achieved single source of truth through componentization",
      "Enhanced state machine with enum-based transitions",
      "Improved modularity and maintainability",
      "Added robust recovery mechanisms"
    ],
    "files_affected": [
      "src/tunacode/core/agents/main.py",
      "src/tunacode/core/agents/agent_components/*",
      "src/tunacode/core/agents/utils.py",
      "Documentation files (AGENTS.md, TODO.md)"
    ]
  }
}
